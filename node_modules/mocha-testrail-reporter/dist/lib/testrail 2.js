"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRail = void 0;
const request = require("unirest");
/**
 * TestRail basic API wrapper
 */
class TestRail {
    constructor(options) {
        this.options = options;
        // check if all required options are specified
        ["username", "password", "domain", "projectId", "projectId"].forEach((option) => {
            if (!options[option]) {
                throw new Error(`Missing required option ${option}`);
            }
        });
        // compute base url
        this.base = `https://${options.domain}/index.php`;
    }
    _post(api, body, callback, error) {
        request("POST", this.base)
            .query(`/api/v2/${api}`)
            .headers({
            "content-type": "application/json",
        })
            .type("json")
            .send(body)
            .auth(this.options.username, this.options.password)
            .end((res) => {
            if (res.error) {
                console.log("Error: %s", JSON.stringify(res.body));
                if (error) {
                    error(res.error);
                }
                else {
                    throw new Error(res.error);
                }
            }
            callback(res.body);
        });
    }
    _get(api, callback, error) {
        request("GET", this.base)
            .query(`/api/v2/${api}`)
            .headers({
            "content-type": "application/json",
        })
            .type("json")
            .auth(this.options.username, this.options.password)
            .end((res) => {
            if (res.error) {
                console.log("Error: %s", JSON.stringify(res.body));
                if (error) {
                    error(res.error);
                }
                else {
                    throw new Error(res.error);
                }
            }
            callback(res.body);
        });
    }
    /**
     * Fetchs test cases from projet/suite based on filtering criteria (optional)
     * @param {{[p: string]: number[]}} filters
     * @param {Function} callback
     */
    fetchCases(filters, callback) {
        let filter = "";
        if (filters) {
            for (let key in filters) {
                if (filters.hasOwnProperty(key)) {
                    filter += "&" + key + "=" + filters[key].join(",");
                }
            }
        }
        this._get(`get_cases/${this.options.projectId}&suite_id=${this.options.suiteId}${filter}`, (body) => {
            if (callback) {
                callback(body.cases);
            }
        });
    }
    /**
     * Publishes results of execution of an automated test run
     * @param {string} name
     * @param {string} description
     * @param {TestRailResult[]} results
     * @param {Function} callback
     */
    publish(name, description, results, callback) {
        console.log(`Publishing ${results.length} test result(s) to ${this.base}`);
        this._post(`add_run/${this.options.projectId}`, {
            suite_id: this.options.suiteId,
            name: name,
            description: description,
            assignedto_id: this.options.assignedToId,
            include_all: true,
        }, (body) => {
            const runId = body.id;
            console.log(`Results published to ${this.base}?/runs/view/${runId}`);
            this._post(`add_results_for_cases/${runId}`, {
                results: results,
            }, (body) => {
                // execute callback if specified
                if (callback) {
                    callback(body);
                }
            });
        });
    }
}
exports.TestRail = TestRail;
//# sourceMappingURL=testrail.js.map